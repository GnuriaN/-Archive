# Object-oriented programmin 

Объtктно-ориентbрованное программbрование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.

Идеологически ООП — подход к программированию как к моделированию информационных объектов, решающий на новом уровне основную задачу структурного программирования: структурирование информации с точки зрения управляемости, что существенно улучшает управляемость самим процессом моделирования, что в свою очередь особенно важно при реализации крупных проектов.

Управляемость для иерархических систем предполагает минимизацию избыточности данных (аналогичную нормализации) и их целостность, поэтому созданное удобно управляемым — будет и удобно пониматься. Таким образом через тактическую задачу управляемости решается стратегическая задача — транслировать понимание задачи программистом в наиболее удобную для дальнейшего использования форму.

Основные принципы структурирования в случае ООП связаны с различными аспектами базового понимания предметной задачи, которое требуется для оптимального управления соответствующей моделью:
* абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете — контекстное понимание предмета, формализуемое в виде класса;
* инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;
* наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;
* полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.

### Абстракция
в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

### **Наследование**
(англ. _inheritance_) — концепция объектно-ориентированного программирования, согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения.

Класс, опредёленный через наследование от другого класса, называется: **производным классом**, **классом потомком** (англ. _derived class_) или **подклассом** (англ. subclass). Класс, от которого новый класс наследуется, называется: **предком** (англ. _parent_), **базовым классом** (англ. _base class_) или **суперклассом** (англ. _parent class_).

Наследование является механизмом повторного использования кода (англ. _code reuse_) и способствует независимому расширению программного обеспечения через открытые классы (англ. _public classes_) и интерфейсы (англ. _interfaces_). Установка отношения наследования между классами порождает иерархию классов (англ. _class hierarchy_).

Часто наследование отождествляют с полиморфизмом подтипов (англ. subtyping):
* Концептуально, полиморфизм подтипов устанавливает отношение: «является» (англ. is-a relationship), — тем самым имитируя семантическое отношение наследования;
* В свою очередь наследование в большей степени относится к повторному использованию кода, то есть определяет синтаксическое отношение.
Несмотря на приведённое выше замечание, наследование является широко используемым механизмом установки отношения «является» (англ. is-a relationship). Некоторые языки программирования согласуют наследование и полиморфизм подтипов (в основном, это относится к языкам со статической типизацией: C++, C#, Java и Scala) — в то время как другие разделяют вышеописанные концепции.

**Наследование**, — даже в языках программирования, которые поддерживают применение наследования как механизма, обеспечивающего полиморфизм подтипов, — не гарантирует поведенческий полиморфизм подтипов; смотри: «Принцип подстановки» Барбары Лисков.

### Инкапсуляция
(англ. _encapsulation_, от лат. _in capsula_) — упаковка данных и функций в единый компонент.

Инкапсуляция зачастую рассматривается как понятие, присущее исключительно объектно-ориентированному программированию (ООП). Инкапсуляция тесно связана с принципом абстракции данных (использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи). Это, в частности, приводит к другому распространённому заблуждению — рассмотрению инкапсуляции неотрывно от сокрытия.

> **Cокрытие** представляет собой принцип проектирования, заключающийся в разграничении доступа различных частей программы к внутренним компонентам друг друга. В одних языках тесно пересекается (вплоть до отождествления) с инкапсуляцией, в других эти понятия абсолютно независимы. В некоторых языках (например, Python) сокрытие отсутствует, хотя возможности инкапсуляции развиты хорошо. Полное сокрытие также обеспечивает лексическая область видимости, которая во многих задачах делает ненужным применение средств инкапсуляции.

В общем случае в разных языках программирования термин «инкапсуляция» относится к одной или обеим одновременно следующим нотациям:
* механизм языка, позволяющий ограничить доступ одних компонентов программы к другим;
* языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.


### Полиморфизм
(от англ. _Polymorphism_) - способность функции обрабатывать данные разных типов.


### Класс
— это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию. Другие абстрактные типы данных — метаклассы, интерфейсы, структуры, перечисления, — характеризуются какими-то своими, другими особенностями. Наряду с понятием «объекта» класс является ключевым понятием в ООП. Суть отличия классов от других абстрактных типов данных состоит в том, что при задании типа данных класс определяет одновременно как интерфейс, так и реализацию для всех своих экземпляров, а вызов метода-конструктора обязателен.
https://ru.wikipedia.org/wiki/Класс_(программирование)

**Абстрактный класс** в объектно-ориентированном программировании — **базовый класс**, который не предполагает создания экземпляров. Абстрактные классы реализуют на практике один из принципов ООП — полиморфизм. Абстрактный класс может содержать (и не содержать) абстрактные методы и свойства. _Абстрактный метод не реализуется для класса_, в котором описан, однако _должен быть реализован для его неабстрактных потомков_. Абстрактные классы представляют собой наиболее общие абстракции, то есть имеющие наибольший объём и наименьшее содержание.

**Интерфейс** (англ. _interface_) — программная/синтаксическая структура, определяющая отношение между объектами, которые разделяют определённое поведенческое множество и не связаны никак иначе. При проектировании классов, разработка интерфейса тождественна разработке спецификации (множества методов, которые каждый класс, использующий интерфейс, должен реализовывать).

Интерфейсы, наряду с абстрактными классами и протоколами, устанавливают взаимные обязательства между элементами программной системы, что является фундаментом концепции программирования по контракту (англ. design by contract, DbC).  Интерфейс определяет границу взаимодействия между классами или компонентами, специфицируя определённую абстракцию, которую осуществляет реализующая сторона.


## S.O.L.I.D.

| Инициал | Представляет | Название, понятие |
|  :--: | :--: | :-- |
| S | SRP | **Принцип единственной ответственности** (_The Single Responsibility Principle_). Существует лишь одна причина, приводящая к изменению класса. |
| O | OCP | **Принцип открытости/закрытости** (_The Open Closed Principle_). «программные сущности … должны быть открыты для расширения, но закрыты для модификации.» |
| L| LSP | **Принцип подстановки Барбары Лисков** (_The Liskov Substitution Principle_). «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый. |
| I | ISP | **Принцип разделения интерфейса** (_The Interface Segregation Principle_). «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.» |
| D| DIP | **Принцип инверсии зависимостей** (_The Dependency Inversion Principle_) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»|


### **Принцип единственной ответственности**
(англ. _The Single Responsibility Principle, SRP_) обозначает, что каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

SRP стоит применять в зависимости от того, как изменяется приложение:
* если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.
* если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.

Пример класса, который подаёт признаки нарушения SRP принципа.
Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения, его поддержки и тестированию. SRP стоит применять только тогда, когда это оправдано. Принцип SRP можно применить только в том случае, когда:
* объекту класса становится позволительно слишком много;
* доменная логика концентрируется только в одном классе;
* любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;
* приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;
* невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.


### **Принцип открытости/закрытости**
(англ. _The Open Closed Principle, OCP_) устанавливает следующее положение: «программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения».

Принцип открытости/закрытости означает, что программные сущности должны быть:

* **открыты для расширения**: _означает, что поведение сущности может быть расширено путём создания новых типов сущностей._
* **закрыты для изменения**: _в результате расширения поведения сущности, не должны вноситься изменения в код, который эти сущности использует._


### **Принцип подстановки Барбары Лисков**
(англ. _Liskov Substitution Principle, LSP_) является специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под названием Абстракция данных и иерархия. _Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом._

Принцип подстановки (замещения) Лисков имеет близкое отношение к методологии контрактного программирования, и ведёт к некоторым ограничениям на то, как контракты могут взаимодействовать с наследованием:
* Предусловия не могут быть усилены в подклассе.
* Постусловия не могут быть ослаблены в подклассе.
* Исторические ограничения ("правило истории") - подкласс не должен создавать новых мутаторов свойств базового класса*.

_* Если базовый класс не предусматривал методов для изменения определенных в нем свойств, подтип этого класса так же не должен создавать таких методов. Иными словами, неизменяемые данные базового класса не должны быть изменяемыми в подклассе. Данная концепция, представленная Лисков и Винг, являлась новаторской для теории программной архитектуры._

Также принцип LSP подразумевает, что методы подкласса не могут генерировать никаких дополнительных исключений, кроме тех, которые сами являются подклассами исключений, генерируемых методами надкласса. См. Ковариантность и контравариантность и типы данных.

Функция, использующая иерархию классов с нарушениями принципа Лисков, помимо оперирования ссылкой на базовый класс, оказывается также вынуждена знать и о подклассе. Подобная функция нарушает принцип открытости/закрытости, поскольку она требует модификации в случае появления в системе новых производных классов.

В данном контексте принцип подстановки можно переформулировать следующим образом: _Функции, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом._


### **Принцип разделения интерфейса**
(англ. _Interface Segregation Principle, ISP_) - Клиенты не должны зависеть от методов, которые они не используют.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.


### **Принцип инверсии зависимостей**
(англ. dependency inversion principle, DIP)

Формулировка:
* Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
